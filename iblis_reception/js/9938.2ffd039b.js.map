{"version":3,"file":"js/9938.2ffd039b.js","mappings":"uLA2BM,SAAUA,EAAWC,EAA8BC,GACrD,MAAMC,EAAOC,OAAOC,OAAOD,OAAOC,OAAOJ,IACnCI,EAAcF,EAAKG,QAAQH,KAClBA,EAAKD,KAEfK,QAAO,CAACC,EAAmBC,KACpBC,MAAMC,QAAQF,EAAIP,IAClBM,EAAaN,GAAOO,EAAIP,GAExBM,EAAaN,GAAO,IAAIM,EAAaN,MAAQO,EAAIP,IAE9CM,IACR,CAAC,GACR,OAAOH,CACX,C,yOCtBA,SAA4BO,EAAAA,EAAAA,IAAiB,CAC3CC,OAAQ,WACRC,KAAAA,CAAMC,GCQR,MAAMC,GAAUC,EAAAA,EAAAA,MAEVC,IADUD,EAAAA,EAAAA,OACSA,EAAAA,EAAAA,KAAa,IAChCE,GAAYF,EAAAA,EAAAA,KAAa,GAEzBG,EAAcA,KAClBD,EAAUE,OAAQ,GAClBC,EAAAA,EAAAA,GAAcH,EAAUE,MAAOL,EAAQK,MAAM,EAGzCE,GAAQC,EAAAA,EAAAA,MACRC,GAASC,EAAAA,EAAAA,MAETC,EAAiBA,KACrB,MAAMC,EAAoB,GAC1B,MAAO,CACLC,GAAI,aACJC,SAAU,aACVC,KAAMC,EAAAA,EAAUC,UAChBC,aAAa,EACbC,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,GACjD6B,cAAgB7B,IACP,CACL8B,UAAW,CACTC,eAAgB/B,EAAIY,SAI1BoB,KAAMC,UAAW,IAAAC,EACf,MAAMC,QAAYnB,EAAOoB,QAAQ,mBACjC,QAAQ,OAAHD,QAAG,IAAHA,IAAAA,EAAKE,MACF,QAARH,EAAAC,EAAIzC,YAAI,IAAAwC,GAARA,EAAUxC,KAAK4C,SAAShB,IACtBH,EAAQoB,KAAK,CACXC,MAAOlB,EAAKmB,KACZ7B,MAAOU,EAAKF,IACZ,KAEG,EAAI,EAEbD,QAASA,IAAMA,EAChB,EAGGuB,EAA2BA,KACxB,CACLtB,GAAI,YACJC,SAAU,uBACVC,KAAMC,EAAAA,EAAUoB,QAChBd,cAAgB7B,IACP,CACL4C,MAAO,CACLC,aAAc7C,EAAIY,SAIxBO,QAASc,UAAiB,IAAAa,EACxB,GAAe,QAAfA,EAAIC,EAAEC,iBAAS,IAAAF,GAAXA,EAAalC,MAAO,KAAAqC,EACtB,MAAMd,QAAYnB,EAAOoB,QACvB,wCACA,CACEK,KAAiB,QAAbQ,EAAEF,EAAEC,iBAAS,IAAAC,OAAA,EAAXA,EAAarC,QAGvB,OAAU,OAAHuB,QAAG,IAAHA,OAAG,EAAHA,EAAKzC,KAAKwD,KAAKC,IAAS,CAAQX,MAAOW,EAAGvC,MAAOuC,K,CAE1D,MAAO,EAAE,EAEXzB,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,KAI/CoD,EAAmBA,KAChB,CACLhC,GAAI,YACJC,SAAU,iCACVC,KAAMC,EAAAA,EAAUoB,QAChBd,cAAgB7B,IACP,CACL4C,MAAO,CACLS,cAAiB,OAAHrD,QAAG,IAAHA,OAAG,EAAHA,EAAKY,QAAS,QAOhC0C,EAA0BA,KAC9B,IAAIC,EAAmC,KACvC,MAAO,CACLnC,GAAI,OACJC,SAAU,2BACVI,aAAa,EACbH,KAAMC,EAAAA,EAAUC,UAChBQ,KAAMC,UACJ,MAAMuB,QAAoBxC,EAAOoB,QAAQ,UAIzC,OAHIoB,EAAOnB,KACTkB,EAAoBC,EAAO9D,KAAK0B,KAE3B,CAAI,EAEbqC,OAAQ,CACNC,cAAc,GAEhB7B,cAAgB7B,IACP,CACL8B,UAAW,CACT6B,iBAAkB3D,EAAIY,MACtBgD,iBAAkBL,IAAsB,KAI9C7B,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,GACjDmB,QAASc,UACP,MAAME,QAAiBnB,EAAOoB,QAC5B,6DACA,CACEyB,kBAAmBd,EAAEe,WAAWlD,QAGpC,OAAQuB,EAAIzC,MAAQ,IAAIwD,KAAKxD,IACpB,CACL8C,MAAO9C,EAAK+C,KACZ7B,MAAOlB,EAAK0B,MAEd,EAEL,EAGG2C,EAAYA,KACT,CACL3C,GAAI,OACJC,SAAU,OACVC,KAAMC,EAAAA,EAAUyC,eAChBtC,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,KAI/CiE,EAAoBA,KACxB,IAAI9C,EAAoB,GACxB,MAAO,CACLC,GAAI,gBACJC,SAAU,gBACVC,KAAMC,EAAAA,EAAUC,UAChBC,aAAa,EACbO,KAAMC,UACJ,MAAME,QAAYnB,EAAOoB,QAAQ,YACjC,QAAQ,OAAHD,QAAG,IAAHA,IAAAA,EAAKE,MACVlB,EAAUgB,EAAIzC,KAAKwD,KAAKxD,IAAS,CAC/B8C,MAAO9C,EAAK+C,KACZ7B,MAAOlB,EAAK0B,QAEP,EAAI,EAEbqC,OAAQ,CACNC,cAAc,GAEhBvC,QAASA,IAAMA,EACfO,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,GAClD,EAGGkE,EAAgBA,KACpB,IAAI/C,EAAoB,GACxB,MAAO,CACLC,GAAI,WACJC,SAAU,mBACVC,KAAMC,EAAAA,EAAUC,UAChBK,cAAgB7B,IACP,CACL4C,MAAO,CACLuB,SAAUnE,EAAIY,SAIpBc,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,GACjDgC,KAAMC,UACJ,MAAME,QAAYnB,EAAOoB,QAAQ,cACjC,QAAQ,OAAHD,QAAG,IAAHA,IAAAA,EAAKE,MACVlB,EAAUgB,EAAIzC,KAAKwD,KAAKxD,IAAS,CAC/B8C,MAAO9C,EAAK+C,KACZ7B,MAAOlB,EAAK0B,QAEP,EAAI,EAEbD,QAASA,IAAMA,EAChB,EAGGiD,EAAgBA,KACpB,IAAIjD,EAAoB,GACpBkD,EAA4B,KAChC,MAAO,CACLjD,GAAI,aACJC,SAAU,oBACVC,KAAMC,EAAAA,EAAU+C,mBAChBb,OAAQ,CACNC,cAAc,GAEhB7B,cAAeA,CAAC7B,EAAe+C,KACtB,CACLwB,MAAOvE,EAAIkD,KAAKC,IACP,CACLqB,SAAUzB,EAAE0B,cAAc7D,MAC1B8D,UAAWvB,EAAEvC,YAKrBO,QAASc,UAAiB,IAAA0C,EACxB,MAAMC,QAAiB5D,EAAOoB,QAAQ,YAAYtB,EAAM+D,OAAOC,aACzDC,EAAqB,OAARH,QAAQ,IAARA,GAAc,QAAND,EAARC,EAAUlF,YAAI,IAAAiF,GAAdA,EAAgBK,IAAIC,MAAM,MAAQ,SAAW,OAChE,GAAIlC,EAAE0B,cAAc7D,OAASyD,EAAY,CACvClD,EAAU,GACVkD,EAAatB,EAAE0B,cAAc7D,MAC7B,MAAMuB,QAAiBnB,EAAOoB,QAAQ,sBAAuB,CAC3D8C,YAAab,EACbW,IAAKD,IAEP,GAAQ,OAAH5C,QAAG,IAAHA,IAAAA,EAAKE,GAAI,MAAO,GACrBlB,EAAUgB,EAAIzC,KAAKwD,KAAKiC,IAAgB,CACtC3C,MAAO2C,EACPvE,MAAOuE,K,CAGX,OAAOhE,CAAO,EAEhBO,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,GACzC,EAGNoF,EAA2BA,KACxB,CACLhE,GAAI,wBACJC,SAAU,wBACVC,KAAMC,EAAAA,EAAU8D,QAChBxD,cAAeA,CAAC7B,EAAa+C,KACpB,CACLH,MAAO,CACL0C,sBAAuB,GAAGvC,EAAEwC,QAAQvF,EAAIY,WAI9Cc,WAAa1B,GAAgB2B,EAAAA,EAAWC,SAAS5B,KAI/CwF,EAAS,CACbtE,IACAoC,IACAZ,IACAU,IACAa,IACAG,IACAL,IACAqB,IACAlB,KAGIuB,EAAWxD,MAAOyD,EAAQhG,KAAa,IAAAiG,EAC3C,MAAMC,EAAe,IAAIC,EAAAA,GACnB,YAAEC,EAAW,MAAEC,IAAU9E,EAAAA,EAAAA,MACzB+E,EAAsB,QAAdL,EAAGI,EAAMnF,aAAK,IAAA+E,GAAe,QAAfA,EAAXA,EAAaM,qBAAa,IAAAN,OAAA,EAA1BA,EAA4BO,KACvCC,EAAgBH,EAASI,cAAcvG,QAC1CwG,GAA0BA,EAAS5D,MAAQqD,MAGxCtG,EAAU,CACdwB,OAAQ,CACNI,GAAIkF,SAAS,GAAGxF,EAAM+D,OAAOC,cAE/ByB,aAAcJ,EAAc,GAAG/E,OAC5B7B,EAAAA,EAAAA,GAAWG,EAAM,iBACjBH,EAAAA,EAAAA,GAAWG,EAAM,aACjBH,EAAAA,EAAAA,GAAWG,EAAM,UAEtBe,EAAiBG,OAAQ,EACzBI,EACGwF,SAAS,SAAUhH,GACnBiH,MAAMtE,IACL5B,EAAQK,MAAQuB,EAAIzC,KAEpB,MAAMgH,EAAmBvE,EAAIzC,KAAKgH,iBAElC,IAAKvE,EAAIE,GAAI,OAAOsE,EAAAA,EAAAA,IAAaxE,EAAIyE,OAErChB,EAAaiB,SACX,4BACA,CAAEH,oBACF,GAAGA,SAELjG,EAAiBG,OAAQ,EACzBF,EAAUE,OAAQ,EAClB,IACEkG,EAAAA,EAAOvE,KAAK,S,CACZ,MAAOqE,GACPG,QAAQC,IAAIJ,E,EAGdK,EAAAA,EAAAA,IAAa,0BACbtG,GAAa,IAEduG,OAAM,KACLzG,EAAiBG,OAAQ,GACzBuG,EAAAA,EAAAA,IAAYC,EAAAA,GAAYC,cAAc,GACtC,EDHN,MAAO,CAACC,EAAUC,MACRC,EAAAA,EAAAA,OAAcC,EAAAA,EAAAA,IAAoB,MAAO,KAAM,EACrDC,EAAAA,EAAAA,IAAaC,EAAAA,EAAW,CACtBnC,OAAQA,EACRC,SAAUA,EACVmC,aAAa,EACbC,iBAAkBpH,EAAiBG,MACnCkH,sBAAuB,SACtB,KAAM,EAAG,CAAC,qBACbP,EAAO,KAAOA,EAAO,IAAKQ,EAAAA,EAAAA,IAAoB,MAAO,CAAE3G,GAAI,iBAAmB,MAAO,MAGzF,IEpVM4G,EAAc,EAEpB,G","sources":["webpack://IBLISReception/./src/utils/Form.ts","webpack://IBLISReception/./src/views/NewOrder.vue?1390","webpack://IBLISReception/./src/views/NewOrder.vue","webpack://IBLISReception/./src/views/NewOrder.vue?9af2"],"sourcesContent":["/**\n * E.g. \n *  payload: {\n *      first_name: {\n *          person: \"Andrew\"\n *      },\n *      last_name: {\n *          person: \"Mfune\"\n *      },\n *      gender: {\n *          person: \"F\"\n *      }\n *  }\n * \n *  tag: \"person\"\n * \n *  result: {\n *      person: {\n *          first_name: \"Andrew\",\n *          last_name: \"Mfune\",\n *          gender: \"F\"\n *      }\n *  }\n * @param payload \n * @param tag \n * @returns \n */\nexport function groupByTag(payload: Record<string, any>, tag: string) {\n    const data = Object.values(Object.values(payload))\n    const values: any = data.filter((data: any) => {\n            return data[tag] ? true : false\n        })\n        .reduce((finalPayload: any, val: any) => {\n            if (Array.isArray(val[tag])) {\n                finalPayload[tag] = val[tag]\n            } else {\n                finalPayload[tag] = {...finalPayload[tag],...val[tag]} \n            }\n            return finalPayload\n        }, {})\n    return values\n}","import { defineComponent as _defineComponent } from 'vue'\nimport { createVNode as _createVNode, createElementVNode as _createElementVNode, openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\"\n\nimport Validation from \"@/components/Forms/validations/StandardValidations\";\nimport TouchForm from \"@/components/Forms/TouchScreenForm.vue\";\nimport { FieldType } from \"@/components/Forms/BaseFormElements\";\nimport { Field, Option } from \"@/components/Forms/FieldInterface\";\nimport { Client, ClientError } from \"@/composables/client\";\nimport { groupByTag } from \"@/utils/Form\";\nimport { useRoute } from \"vue-router\";\nimport { toastDanger, toastSuccess, toastWarning } from \"@/utils/Alerts\";\nimport PrintService from \"@/services/print_service\";\n\nimport { ref } from \"vue\";\nimport { PatientDialog } from \"@/utils/PatientDialog\";\nimport router from \"@/router\";\nimport { LabLocation } from \"types\";\n\n\nexport default /*@__PURE__*/_defineComponent({\n  __name: 'NewOrder',\n  setup(__props) {\n\nconst details = ref<any>();\nconst patient = ref();\nconst isFinishDisabled = ref<boolean>(false);\nconst modalOpen = ref<boolean>(false);\n\nconst handleModal = () => {\n  modalOpen.value = true;\n  PatientDialog(modalOpen.value, details.value);\n};\n\nconst route = useRoute();\nconst client = Client();\n\nconst visitTypeField = () => {\n  const options: Option[] = [];\n  return {\n    id: \"visit_type\",\n    helpText: \"Visit type\",\n    type: FieldType.TT_SELECT,\n    requireNext: false,\n    validation: (val: Option) => Validation.required(val),\n    computedValue: (val: Option) => {\n      return {\n        encounter: {\n          encounter_type: val.value,\n        },\n      };\n    },\n    init: async () => {\n      const res = await client.getJson(\"encounter_types\");\n      if (!res?.ok) return false;\n      res.data?.data.forEach((type: any) => {\n        options.push({\n          label: type.name,\n          value: type.id,\n        });\n      });\n      return true;\n    },\n    options: () => options,\n  };\n};\n\nconst requestingClinicianField = () => {\n  return {\n    id: \"clinician\",\n    helpText: \"Requesting Clinician\",\n    type: FieldType.TT_TEXT,\n    computedValue: (val: Option) => {\n      return {\n        order: {\n          requested_by: val.value,\n        },\n      };\n    },\n    options: async (f: any) => {\n      if (f.clinician?.value) {\n        const res = await client.getJson(\n          \"orders/search_by_requesting_clinician\",\n          {\n            name: f.clinician?.value,\n          }\n        );\n        return res?.data.map((v: string) => ({ label: v, value: v }));\n      }\n      return [];\n    },\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst collectedByField = () => {\n  return {\n    id: \"collector\",\n    helpText: \"Sample collected by (Optional)\",\n    type: FieldType.TT_TEXT,\n    computedValue: (val: Option) => {\n      return {\n        order: {\n          collected_by: val?.value || \"\",\n        },\n      };\n    },\n  };\n};\n\nconst requestingLocationField = () => {\n  let sendingFacilityID: null | number = null;\n  return {\n    id: \"ward\",\n    helpText: \"Requesting ward/location\",\n    requireNext: false,\n    type: FieldType.TT_SELECT,\n    init: async () => {\n      const global: any = await client.getJson(\"global\");\n      if (global.ok) {\n        sendingFacilityID = global.data.id;\n      }\n      return true;\n    },\n    config: {\n      showKeyboard: true,\n    },\n    computedValue: (val: Option) => {\n      return {\n        encounter: {\n          facility_section: val.value,\n          sending_facility: sendingFacilityID || -1,\n        },\n      };\n    },\n    validation: (val: Option) => Validation.required(val),\n    options: async (f: any) => {\n      const res: any = await client.getJson(\n        \"encounter_type_facility_section_mappings/facility_sections\",\n        {\n          encounter_type_id: f.visit_type.value,\n        }\n      );\n      return (res.data || []).map((data: any) => {\n        return {\n          label: data.name,\n          value: data.id,\n        };\n      });\n    },\n  };\n};\n\nconst dateField = () => {\n  return {\n    id: \"date\",\n    helpText: \"Date\",\n    type: FieldType.TT_DATE_PICKER,\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst specimenTypeField = () => {\n  let options: Option[] = [];\n  return {\n    id: \"specimen_type\",\n    helpText: \"Specimen type\",\n    type: FieldType.TT_SELECT,\n    requireNext: false,\n    init: async () => {\n      const res = await client.getJson(\"specimen\");\n      if (!res?.ok) return false;\n      options = res.data.map((data: any) => ({\n        label: data.name,\n        value: data.id,\n      }));\n      return true;\n    },\n    config: {\n      showKeyboard: true,\n    },\n    options: () => options,\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst priorityField = () => {\n  let options: Option[] = [];\n  return {\n    id: \"priority\",\n    helpText: \"Specify priority\",\n    type: FieldType.TT_SELECT,\n    computedValue: (val: Option) => {\n      return {\n        order: {\n          priority: val.value,\n        },\n      };\n    },\n    validation: (val: Option) => Validation.required(val),\n    init: async () => {\n      const res = await client.getJson(\"priorities\");\n      if (!res?.ok) return false;\n      options = res.data.map((data: any) => ({\n        label: data.name,\n        value: data.id,\n      }));\n      return true;\n    },\n    options: () => options,\n  };\n};\n\nconst testTypeField = () => {\n  let options: Option[] = [];\n  let specimenID: number | null = null;\n  return {\n    id: \"test_types\",\n    helpText: \"Select test types\",\n    type: FieldType.TT_MULTIPLE_SELECT,\n    config: {\n      showKeyboard: true,\n    },\n    computedValue: (val: Option[], f: any) => {\n      return {\n        tests: val.map((v: Option) => {\n          return {\n            specimen: f.specimen_type.value,\n            test_type: v.value,\n          };\n        }),\n      };\n    },\n    options: async (f: any) => {\n      const response = await client.getJson(`/clients/${route.params.client_id}`);\n      const patientSex = response?.data?.sex.match(/f/i) ? \"Female\" : \"Male\"\n      if (f.specimen_type.value != specimenID) {\n        options = [];\n        specimenID = f.specimen_type.value;\n        const res: any = await client.getJson(\"specimen/test_types\", {\n          specimen_id: specimenID as number,\n          sex: patientSex\n        });\n        if (!res?.ok) return [];\n        options = res.data.map((testType: string) => ({\n          label: testType,\n          value: testType,\n        }));\n      }\n      return options;\n    },\n    validation: (val: Option) => Validation.required(val),\n  } as Field;\n};\n\nconst timeSampleCollectedField = () => {\n  return {\n    id: \"time_sample_collected\",\n    helpText: \"Time Sample Collected\",\n    type: FieldType.TT_TIME,\n    computedValue: (val: Option, f: any) => {\n      return {\n        order: {\n          sample_collected_time: `${f.date} ${val.value}`,\n        },\n      };\n    },\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst fields = [\n  visitTypeField(),\n  requestingLocationField(),\n  requestingClinicianField(),\n  collectedByField(),\n  specimenTypeField(),\n  testTypeField(),\n  dateField(),\n  timeSampleCollectedField(),\n  priorityField(),\n];\n\nconst onFinish = async (_: any, data: any) => {\n  const printService = new PrintService();\n  const { getLocation, token } = Client();\n  const userData = token.value?.authorization?.user;\n  const labLocationID = userData.lab_locations.filter(\n    (location: LabLocation) => location.name == getLocation()\n  );\n\n  const payload = {\n    client: {\n      id: parseInt(`${route.params.client_id}`),\n    },\n    lab_location: labLocationID[0].id,\n    ...groupByTag(data, \"encounter\"),\n    ...groupByTag(data, \"order\"),\n    ...groupByTag(data, \"tests\"),\n  };\n  isFinishDisabled.value = true;\n  client\n    .postJson(\"orders\", payload)\n    .then((res: any) => {\n      details.value = res.data;\n\n      const accession_number = res.data.accession_number;\n\n      if (!res.ok) return toastWarning(res.error);\n\n      printService.writeLbl(\n        \"printout/accession_number\",\n        { accession_number },\n        `${accession_number}.lbl`\n      );\n      isFinishDisabled.value = false;\n      modalOpen.value = true;\n      try {\n        router.push(`/tests`);\n      } catch (error) {\n        console.log(error);\n      }\n\n      toastSuccess(\"Order as been created!\");\n      handleModal();\n    })\n    .catch(() => {\n      isFinishDisabled.value = false;\n      toastDanger(ClientError.GENERAL_ERROR)\n    });\n};\n\nreturn (_ctx: any,_cache: any) => {\n  return (_openBlock(), _createElementBlock(\"div\", null, [\n    _createVNode(TouchForm, {\n      fields: fields,\n      onFinish: onFinish,\n      skipSummary: true,\n      onFinishDisabled: isFinishDisabled.value,\n      cancelDestinationPath: \"/home\"\n    }, null, 8, [\"onFinishDisabled\"]),\n    _cache[0] || (_cache[0] = _createElementVNode(\"div\", { id: \"rootContainer\" }, null, -1))\n  ]))\n}\n}\n\n})","<template>\n  <div>\n    <TouchForm\n      :fields=\"fields\"\n      :onFinish=\"onFinish\"\n      :skipSummary=\"true\"\n      :onFinishDisabled=\"isFinishDisabled\"\n      cancelDestinationPath=\"/home\"\n    />\n    <div id=\"rootContainer\"></div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport Validation from \"@/components/Forms/validations/StandardValidations\";\nimport TouchForm from \"@/components/Forms/TouchScreenForm.vue\";\nimport { FieldType } from \"@/components/Forms/BaseFormElements\";\nimport { Field, Option } from \"@/components/Forms/FieldInterface\";\nimport { Client, ClientError } from \"@/composables/client\";\nimport { groupByTag } from \"@/utils/Form\";\nimport { useRoute } from \"vue-router\";\nimport { toastDanger, toastSuccess, toastWarning } from \"@/utils/Alerts\";\nimport PrintService from \"@/services/print_service\";\n\nimport { ref } from \"vue\";\nimport { PatientDialog } from \"@/utils/PatientDialog\";\nimport router from \"@/router\";\nimport { LabLocation } from \"types\";\n\nconst details = ref<any>();\nconst patient = ref();\nconst isFinishDisabled = ref<boolean>(false);\nconst modalOpen = ref<boolean>(false);\n\nconst handleModal = () => {\n  modalOpen.value = true;\n  PatientDialog(modalOpen.value, details.value);\n};\n\nconst route = useRoute();\nconst client = Client();\n\nconst visitTypeField = () => {\n  const options: Option[] = [];\n  return {\n    id: \"visit_type\",\n    helpText: \"Visit type\",\n    type: FieldType.TT_SELECT,\n    requireNext: false,\n    validation: (val: Option) => Validation.required(val),\n    computedValue: (val: Option) => {\n      return {\n        encounter: {\n          encounter_type: val.value,\n        },\n      };\n    },\n    init: async () => {\n      const res = await client.getJson(\"encounter_types\");\n      if (!res?.ok) return false;\n      res.data?.data.forEach((type: any) => {\n        options.push({\n          label: type.name,\n          value: type.id,\n        });\n      });\n      return true;\n    },\n    options: () => options,\n  };\n};\n\nconst requestingClinicianField = () => {\n  return {\n    id: \"clinician\",\n    helpText: \"Requesting Clinician\",\n    type: FieldType.TT_TEXT,\n    computedValue: (val: Option) => {\n      return {\n        order: {\n          requested_by: val.value,\n        },\n      };\n    },\n    options: async (f: any) => {\n      if (f.clinician?.value) {\n        const res = await client.getJson(\n          \"orders/search_by_requesting_clinician\",\n          {\n            name: f.clinician?.value,\n          }\n        );\n        return res?.data.map((v: string) => ({ label: v, value: v }));\n      }\n      return [];\n    },\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst collectedByField = () => {\n  return {\n    id: \"collector\",\n    helpText: \"Sample collected by (Optional)\",\n    type: FieldType.TT_TEXT,\n    computedValue: (val: Option) => {\n      return {\n        order: {\n          collected_by: val?.value || \"\",\n        },\n      };\n    },\n  };\n};\n\nconst requestingLocationField = () => {\n  let sendingFacilityID: null | number = null;\n  return {\n    id: \"ward\",\n    helpText: \"Requesting ward/location\",\n    requireNext: false,\n    type: FieldType.TT_SELECT,\n    init: async () => {\n      const global: any = await client.getJson(\"global\");\n      if (global.ok) {\n        sendingFacilityID = global.data.id;\n      }\n      return true;\n    },\n    config: {\n      showKeyboard: true,\n    },\n    computedValue: (val: Option) => {\n      return {\n        encounter: {\n          facility_section: val.value,\n          sending_facility: sendingFacilityID || -1,\n        },\n      };\n    },\n    validation: (val: Option) => Validation.required(val),\n    options: async (f: any) => {\n      const res: any = await client.getJson(\n        \"encounter_type_facility_section_mappings/facility_sections\",\n        {\n          encounter_type_id: f.visit_type.value,\n        }\n      );\n      return (res.data || []).map((data: any) => {\n        return {\n          label: data.name,\n          value: data.id,\n        };\n      });\n    },\n  };\n};\n\nconst dateField = () => {\n  return {\n    id: \"date\",\n    helpText: \"Date\",\n    type: FieldType.TT_DATE_PICKER,\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst specimenTypeField = () => {\n  let options: Option[] = [];\n  return {\n    id: \"specimen_type\",\n    helpText: \"Specimen type\",\n    type: FieldType.TT_SELECT,\n    requireNext: false,\n    init: async () => {\n      const res = await client.getJson(\"specimen\");\n      if (!res?.ok) return false;\n      options = res.data.map((data: any) => ({\n        label: data.name,\n        value: data.id,\n      }));\n      return true;\n    },\n    config: {\n      showKeyboard: true,\n    },\n    options: () => options,\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst priorityField = () => {\n  let options: Option[] = [];\n  return {\n    id: \"priority\",\n    helpText: \"Specify priority\",\n    type: FieldType.TT_SELECT,\n    computedValue: (val: Option) => {\n      return {\n        order: {\n          priority: val.value,\n        },\n      };\n    },\n    validation: (val: Option) => Validation.required(val),\n    init: async () => {\n      const res = await client.getJson(\"priorities\");\n      if (!res?.ok) return false;\n      options = res.data.map((data: any) => ({\n        label: data.name,\n        value: data.id,\n      }));\n      return true;\n    },\n    options: () => options,\n  };\n};\n\nconst testTypeField = () => {\n  let options: Option[] = [];\n  let specimenID: number | null = null;\n  return {\n    id: \"test_types\",\n    helpText: \"Select test types\",\n    type: FieldType.TT_MULTIPLE_SELECT,\n    config: {\n      showKeyboard: true,\n    },\n    computedValue: (val: Option[], f: any) => {\n      return {\n        tests: val.map((v: Option) => {\n          return {\n            specimen: f.specimen_type.value,\n            test_type: v.value,\n          };\n        }),\n      };\n    },\n    options: async (f: any) => {\n      const response = await client.getJson(`/clients/${route.params.client_id}`);\n      const patientSex = response?.data?.sex.match(/f/i) ? \"Female\" : \"Male\"\n      if (f.specimen_type.value != specimenID) {\n        options = [];\n        specimenID = f.specimen_type.value;\n        const res: any = await client.getJson(\"specimen/test_types\", {\n          specimen_id: specimenID as number,\n          sex: patientSex\n        });\n        if (!res?.ok) return [];\n        options = res.data.map((testType: string) => ({\n          label: testType,\n          value: testType,\n        }));\n      }\n      return options;\n    },\n    validation: (val: Option) => Validation.required(val),\n  } as Field;\n};\n\nconst timeSampleCollectedField = () => {\n  return {\n    id: \"time_sample_collected\",\n    helpText: \"Time Sample Collected\",\n    type: FieldType.TT_TIME,\n    computedValue: (val: Option, f: any) => {\n      return {\n        order: {\n          sample_collected_time: `${f.date} ${val.value}`,\n        },\n      };\n    },\n    validation: (val: Option) => Validation.required(val),\n  };\n};\n\nconst fields = [\n  visitTypeField(),\n  requestingLocationField(),\n  requestingClinicianField(),\n  collectedByField(),\n  specimenTypeField(),\n  testTypeField(),\n  dateField(),\n  timeSampleCollectedField(),\n  priorityField(),\n];\n\nconst onFinish = async (_: any, data: any) => {\n  const printService = new PrintService();\n  const { getLocation, token } = Client();\n  const userData = token.value?.authorization?.user;\n  const labLocationID = userData.lab_locations.filter(\n    (location: LabLocation) => location.name == getLocation()\n  );\n\n  const payload = {\n    client: {\n      id: parseInt(`${route.params.client_id}`),\n    },\n    lab_location: labLocationID[0].id,\n    ...groupByTag(data, \"encounter\"),\n    ...groupByTag(data, \"order\"),\n    ...groupByTag(data, \"tests\"),\n  };\n  isFinishDisabled.value = true;\n  client\n    .postJson(\"orders\", payload)\n    .then((res: any) => {\n      details.value = res.data;\n\n      const accession_number = res.data.accession_number;\n\n      if (!res.ok) return toastWarning(res.error);\n\n      printService.writeLbl(\n        \"printout/accession_number\",\n        { accession_number },\n        `${accession_number}.lbl`\n      );\n      isFinishDisabled.value = false;\n      modalOpen.value = true;\n      try {\n        router.push(`/tests`);\n      } catch (error) {\n        console.log(error);\n      }\n\n      toastSuccess(\"Order as been created!\");\n      handleModal();\n    })\n    .catch(() => {\n      isFinishDisabled.value = false;\n      toastDanger(ClientError.GENERAL_ERROR)\n    });\n};\n</script>\n","import script from \"./NewOrder.vue?vue&type=script&setup=true&lang=ts\"\nexport * from \"./NewOrder.vue?vue&type=script&setup=true&lang=ts\"\n\nconst __exports__ = script;\n\nexport default __exports__"],"names":["groupByTag","payload","tag","data","Object","values","filter","reduce","finalPayload","val","Array","isArray","_defineComponent","__name","setup","__props","details","ref","isFinishDisabled","modalOpen","handleModal","value","PatientDialog","route","useRoute","client","Client","visitTypeField","options","id","helpText","type","FieldType","TT_SELECT","requireNext","validation","Validation","required","computedValue","encounter","encounter_type","init","async","_res$data","res","getJson","ok","forEach","push","label","name","requestingClinicianField","TT_TEXT","order","requested_by","_f$clinician","f","clinician","_f$clinician2","map","v","collectedByField","collected_by","requestingLocationField","sendingFacilityID","global","config","showKeyboard","facility_section","sending_facility","encounter_type_id","visit_type","dateField","TT_DATE_PICKER","specimenTypeField","priorityField","priority","testTypeField","specimenID","TT_MULTIPLE_SELECT","tests","specimen","specimen_type","test_type","_response$data","response","params","client_id","patientSex","sex","match","specimen_id","testType","timeSampleCollectedField","TT_TIME","sample_collected_time","date","fields","onFinish","_","_token$value","printService","PrintService","getLocation","token","userData","authorization","user","labLocationID","lab_locations","location","parseInt","lab_location","postJson","then","accession_number","toastWarning","error","writeLbl","router","console","log","toastSuccess","catch","toastDanger","ClientError","GENERAL_ERROR","_ctx","_cache","_openBlock","_createElementBlock","_createVNode","TouchForm","skipSummary","onFinishDisabled","cancelDestinationPath","_createElementVNode","__exports__"],"sourceRoot":""}